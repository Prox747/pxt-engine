#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

// Include the global UBO definition
#include "../ubo/global_ubo.glsl"

// Define the ray payload structure. This struct is passed between shader stages.
// The layout(location = 0) specifies the location for the payload.
layout(location = 0) rayPayloadEXT struct RayPayload {
    vec4 color; // The color accumulated along the ray
    float t;    // The hit distance (t-value)
} payload;

// Declare the top-level acceleration structure (TLAS)
layout(set = 1, binding = 0) uniform accelerationStructureEXT TLAS;

// Declare the output storage image
// The format qualifier (e.g., rgba8, rgba32f) should match how the image was created in Vulkan.
// rgba8 is common for 8-bit per channel normalized output. Use rgba32f for HDR float output.
layout(set = 3, binding = 0, rgba8) uniform image2D outputImage;

void main()
{
    // Calculate the ray direction based on the launch ID (pixel coordinates)
    // and the inverse view-projection matrix from the UBO.
    // gl_LaunchIDEXT is the pixel coordinate (x, y, z) of the current invocation.
    // gl_LaunchSizeEXT is the total number of ray generation invocations (width, height, depth).
    vec2 fragCoord = vec2(gl_LaunchIDEXT.xy);
    vec2 screenPos = fragCoord / vec2(gl_LaunchSizeEXT.xy);
    vec2 ndcPos = screenPos * 2.0 - 1.0; // Convert to NDC space [-1, 1]

    // Construct the ray in world space
    // The ray origin is the camera position (inverse of view matrix translation)
    vec4 origin = ubo.inverseViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);

    // The ray target is the point in world space corresponding to the pixel
    vec4 target = ubo.inverseViewMatrix * inverse(ubo.projectionMatrix) * vec4(ndcPos.x, ndcPos.y, 0.0, 1.0);

    // The ray direction is from origin to target
    vec3 direction = normalize(target.xyz - origin.xyz);

    // Initialize payload (optional, but good practice if miss shader might not always be hit)
    payload.color = vec4(0.0, 0.0, 0.0, 1.0); // Default to black
    payload.t = -1.0;

    // --- Launch the ray ---
    traceRayEXT(
        TLAS,
        0,       // rayFlags (gl_RayFlagsOpaqueEXT, gl_RayFlagsNoOpaqueEXT, etc.)
        0xFF,    // cullMask
        0,       // sbtRecordOffset
        0,       // sbtRecordStride
        0,       // missShaderIndex
        origin.xyz,
        0.001,   // tmin (small epsilon to avoid self-intersection)
        direction,
        10000.0, // tmax
        0        // payloadLocation (matches layout(location = 0) of the payload struct)
    );

    // The traceRayEXT call is blocking. When it returns, the payload contains
    // the result from the closest hit shader (if a hit occurred) or the miss shader.

    // Write the final color from the payload to the output storage image
    // gl_LaunchIDEXT.xy provides the integer pixel coordinates for the store operation.
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), payload.color);
}