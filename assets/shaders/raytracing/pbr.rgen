#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

// Include the global UBO definition
#include "../ubo/global_ubo.glsl"
#include "../common/ray.glsl"
#include "../common/random.glsl"


// Define the ray payload structure. This struct is passed between shader stages.
// The layout(location = 0) specifies the location for the payload.
layout(location = 0) rayPayloadEXT struct RayPayload {
    vec3 light;
    vec3 color;
    vec3 normal;
    float t; // The hit distance (t-value)
    uint seed;
} payload;

// Declare the top-level acceleration structure (TLAS)
layout(set = 1, binding = 0) uniform accelerationStructureEXT TLAS;

// Declare the output storage image
// The format qualifier (e.g., rgba8, rgba32f) should match how the image was created in Vulkan.
// rgba8 is common for 8-bit per channel normalized output. Use rgba32f for HDR float output.
layout(set = 3, binding = 0, rgba8) uniform image2D outputImage;

void main()
{
    // gl_LaunchIDEXT is the pixel coordinate (x, y, z) of the current invocation.
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);

    // gl_LaunchSizeEXT is the total number of ray generation invocations (width, height, depth).
    const vec2 imageDimensions = vec2(gl_LaunchSizeEXT.xy);

    vec3 finalColor = vec3(0.0);

    const uint samplesPerPixel = 100;
    const int maxBounces = 50;

    for (uint currentSample = 0; currentSample < samplesPerPixel; currentSample++) {
        uint seed = gl_LaunchIDEXT.x * 1337 + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + 
                   currentSample * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + ubo.frameCount * 17;
        

        // Normalized device coordinates (NDC), converted to [-1, 1] range (NDC space)
        vec2 jitter = vec2(randomFloat(seed), randomFloat(seed)) - 0.5;
        vec2 pixelPos = pixelCenter + jitter;
        
        // Normalized device coordinates
        const vec2 ndc = pixelPos / imageDimensions * 2.0 - 1.0;

        // Ray origin and direction in camera/view space
        // Assuming perspective projection
        vec4 rayOriginView = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 rayTargetView = /*ubo.inverseProjectionMatrix*/ inverse(ubo.projectionMatrix) * vec4(ndc.x, ndc.y, 1.0, 1.0); // Point on far plane

        // Transform ray to world space
        Ray worldRay;
        // Camera position in world space
        worldRay.origin = (ubo.inverseViewMatrix * rayOriginView).xyz; 

        worldRay.direction = normalize((ubo.inverseViewMatrix * vec4(normalize(rayTargetView.xyz / rayTargetView.w), 0.0)).xyz);
    
        vec3 light = vec3(0.0); // Initialize total light contribution
        vec3 color = vec3(1.0); // Initialize final color

        // Initialize payload
    

        // Ray parameters
        uint rayFlags = gl_RayFlagsOpaqueEXT; // Assume opaque geometry for now
        uint cullMask = 0xFF;                 // Standard cull mask
        float tMin    = 0.001;                // Minimum intersection distance
        float tMax    = 10000.0;              // Maximum intersection distance

        for (int bounce = 0; bounce < maxBounces; ++bounce) {
        
            payload.light = light; 
            payload.color = color; 
            payload.seed = seed + bounce * 1337;
            payload.t = -1.0;

            traceRayEXT(
                TLAS,               // Top-level acceleration structure
                rayFlags,           // Ray flags
                cullMask,           // Cull mask
                0,                  // SBT record offset for raygen shader (usually 0)
                0,                  // SBT record stride for raygen shader (usually 0)
                0,                  // Miss shader index (which miss shader in the SBT to use)
                worldRay.origin,    // Ray origin
                tMin,               // Ray min distance
                worldRay.direction, // Ray direction
                tMax,               // Ray max distance
                0                   // Payload location (must match the rayPayloadEXT layout location)
            );

            if (payload.t < 0.0) {
                light += payload.light; // Accumulate light contribution from the sky
                break;
            }

            light += payload.light; // Accumulate light contribution from the hit object
            color *= payload.color; // Accumulate color contribution from the hit object

            // Update the ray origin to the hit point for the next iteration
            worldRay.origin += worldRay.direction * payload.t + payload.normal * 0.0001; // Move to the hit point
            worldRay.direction = payload.normal; // Reflect the ray direction based on the hit normal

            
        }

        finalColor += color * light;
    }

    finalColor /= samplesPerPixel;

    //vec3 previousColor = imageLoad(outputImage, ivec2(gl_LaunchIDEXT.xy)).rgb;
    //float weight = 1.0 / float(ubo.frameCount + 1);
    //vec3 accumulatedColor = mix(previousColor, finalColor, weight);
    
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.0));
}